<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wasteland Candy Crush</title>
    <style>
        body { margin: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background: #1a1a1a; font-family: Arial, sans-serif; }
        #gameContainer { position: relative; }
        canvas { border: 4px solid #4a4a4a; border-radius: 8px; background: linear-gradient(#2f2f2f, #3c3c3c); box-shadow: 0 0 15px rgba(0, 255, 0, 0.2); }
        #ui { 
            display: flex; justify-content: space-between; width: 360px; 
            background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px; 
            color: #0f0; font-size: 18px; margin-bottom: 10px; text-shadow: 0 0 5px #0f0; 
        }
        #ui span { background: #222; padding: 5px 10px; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="ui">
        <span id="score">Score: 0</span>
        <span id="level">Level: 1</span>
        <span id="time">Time: 60</span>
        <span id="goal">Goal: 200</span>
    </div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="360" height="360"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreUI = document.getElementById('score');
        const levelUI = document.getElementById('level');
        const timeUI = document.getElementById('time');
        const goalUI = document.getElementById('goal');

        // Game settings
        const GRID_SIZE = 6;
        const TILE_SIZE = 60;
        const CANDY_TYPES = [
            '#ff5555', // Glowing Gum
            '#55ff55', // Toxic Taffy
            '#5555ff', // Rad Rocks
            '#ffff55', // Mutant Mints
            '#ff55ff', // Irradiated Drops
            '#00ffff'  // Cyan (higher levels)
        ];

        // Game state
        let grid = [];
        let score = 0;
        let level = 1;
        let timeLeft = 60;
        let goal = 200;
        let selected = null;
        let gameOver = false;
        let lastFrame = performance.now();
        let animations = []; // For transition effects

        // Initialize grid
        function initGrid() {
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0).map(() => Math.floor(Math.random() * (3 + Math.min(level, 3)))));
            while (findMatches().length > 0) clearMatches(); // No initial matches
        }
        initGrid();

        // Candy object with position and animation state
        class Candy {
            constructor(x, y, type) {
                this.x = x * TILE_SIZE + TILE_SIZE / 2;
                this.y = y * TILE_SIZE + TILE_SIZE / 2;
                this.targetX = this.x;
                this.targetY = this.y;
                this.type = type;
                this.size = TILE_SIZE / 2 - 10;
                this.opacity = 1;
                this.fallingSpeed = 0;
                this.isClearing = false;
            }

            update(delta) {
                if (this.isClearing) {
                    this.opacity -= delta * 2;
                    if (this.opacity <= 0) return false;
                } else if (this.y < this.targetY) {
                    this.fallingSpeed += 200 * delta; // Gravity-like fall
                    this.y += this.fallingSpeed * delta;
                    if (this.y >= this.targetY) this.y = this.targetY;
                }
                return true;
            }

            draw() {
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = CANDY_TYPES[this.type];
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x - 10, this.y - 10, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Draw grid with animations
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE - 2, TILE_SIZE - 2);
                    if (grid[y][x] !== -1) {
                        const candy = grid[y][x];
                        if (candy instanceof Candy) candy.draw();
                    }
                }
            }
            if (selected) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 4;
                ctx.strokeRect(selected.x * TILE_SIZE, selected.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }

        // Update animations
        function updateAnimations(delta) {
            animations = animations.filter(anim => {
                anim.update(delta);
                return anim.exists;
            });
            if (animations.length === 0) return false;
            return true;
        }

        // Find matches
        function findMatches() {
            let matches = new Set();
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE - 2; x++) {
                    if (grid[y][x] instanceof Candy && grid[y][x].type === grid[y][x + 1]?.type && grid[y][x].type === grid[y][x + 2]?.type) {
                        matches.add(`${x},${y}`);
                        matches.add(`${x + 1},${y}`);
                        matches.add(`${x + 2},${y}`);
                    }
                }
            }
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE - 2; y++) {
                    if (grid[y][x] instanceof Candy && grid[y][x].type === grid[y + 1][x]?.type && grid[y][x].type === grid[y + 2][x]?.type) {
                        matches.add(`${x},${y}`);
                        matches.add(`${x},${y + 1}`);
                        matches.add(`${x},${y + 2}`);
                    }
                }
            }
            return Array.from(matches).map(pos => {
                const [x, y] = pos.split(',').map(Number);
                return { x, y };
            });
        }

        // Clear matches and score
        function clearMatches() {
            let matches = findMatches();
            if (matches.length === 0) return false;
            let comboSize = matches.length;
            score += comboSize >= 5 ? 30 : comboSize === 4 ? 20 : 10;
            matches.forEach(match => {
                if (grid[match.y][match.x] instanceof Candy) {
                    grid[match.y][match.x].isClearing = true;
                    animations.push(grid[match.y][match.x]);
                    grid[match.y][match.x] = -1;
                }
            });
            return true;
        }

        // Drop candies with animation
        function dropCandies() {
            for (let x = 0; x < GRID_SIZE; x++) {
                let emptySpots = [];
                let candies = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (grid[y][x] === -1) emptySpots.push(y);
                    else if (grid[y][x] instanceof Candy) candies.push({ y, candy: grid[y][x] });
                }

                // Shift existing candies down
                candies.sort((a, b) => a.y - b.y); // Sort by y-position
                for (let i = 0; i < candies.length; i++) {
                    let newY = GRID_SIZE - 1 - i;
                    if (emptySpots.includes(newY)) {
                        candies[i].candy.targetY = newY * TILE_SIZE + TILE_SIZE / 2;
                        grid[newY][x] = candies[i].candy;
                        grid[candies[i].y][x] = -1;
                    }
                }

                // Fill empty spots at the top with new candies
                for (let y of emptySpots) {
                    const newCandy = new Candy(x, y, Math.floor(Math.random() * (3 + Math.min(level, 3))));
                    newCandy.targetY = y * TILE_SIZE + TILE_SIZE / 2;
                    newCandy.y = -TILE_SIZE; // Start above canvas
                    grid[y][x] = newCandy;
                    animations.push(newCandy);
                }
            }
        }

        // Check adjacency
        function isAdjacent(pos1, pos2) {
            return (Math.abs(pos1.x - pos2.x) === 1 && pos1.y === pos2.y) || 
                   (Math.abs(pos1.y - pos2.y) === 1 && pos1.x === pos2.x);
        }

        // Swap candies with animation
        function swapCandies(pos1, pos2) {
            const candy1 = grid[pos1.y][pos1.x];
            const candy2 = grid[pos2.y][pos2.x];
            if (!(candy1 instanceof Candy) || !(candy2 instanceof Candy)) return false;

            // Swap positions
            grid[pos1.y][pos1.x] = candy2;
            grid[pos2.y][pos2.x] = candy1;

            // Animate swap
            candy1.targetX = pos2.x * TILE_SIZE + TILE_SIZE / 2;
            candy1.targetY = pos2.y * TILE_SIZE + TILE_SIZE / 2;
            candy2.targetX = pos1.x * TILE_SIZE + TILE_SIZE / 2;
            candy2.targetY = pos1.y * TILE_SIZE + TILE_SIZE / 2;
            animations.push(candy1, candy2);

            const hasMatch = findMatches().length > 0;
            if (!hasMatch) {
                // Undo swap if no match
                grid[pos2.y][pos2.x] = candy2;
                grid[pos1.y][pos1.x] = candy1;
                candy1.targetX = pos1.x * TILE_SIZE + TILE_SIZE / 2;
                candy1.targetY = pos1.y * TILE_SIZE + TILE_SIZE / 2;
                candy2.targetX = pos2.x * TILE_SIZE + TILE_SIZE / 2;
                candy2.targetY = pos2.y * TILE_SIZE + TILE_SIZE / 2;
                animations.push(candy1, candy2);
            }
            return hasMatch;
        }

        // Check for moves
        function hasMoves() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] instanceof Candy) {
                        if (x < GRID_SIZE - 1 && grid[y][x + 1] instanceof Candy) {
                            [grid[y][x], grid[y][x + 1]] = [grid[y][x + 1], grid[y][x]];
                            if (findMatches().length > 0) {
                                [grid[y][x], grid[y][x + 1]] = [grid[y][x + 1], grid[y][x]];
                                return true;
                            }
                            [grid[y][x], grid[y][x + 1]] = [grid[y][x + 1], grid[y][x]];
                        }
                        if (y < GRID_SIZE - 1 && grid[y + 1][x] instanceof Candy) {
                            [grid[y][x], grid[y + 1][x]] = [grid[y + 1][x], grid[y][x]];
                            if (findMatches().length > 0) {
                                [grid[y][x], grid[y + 1][x]] = [grid[y + 1][x], grid[y][x]];
                                return true;
                            }
                            [grid[y][x], grid[y + 1][x]] = [grid[y + 1][x], grid[y][x]];
                        }
                    }
                }
            }
            return false;
        }

        // Level progression
        function nextLevel() {
            if (level >= 10) {
                gameOver = true;
                alert(`Vault Cleared! Final Score: ${score}`);
                return;
            }
            level++;
            timeLeft = 60;
            goal = 200 + 100 * level;
            initGrid(); // Reset grid only on level-up
        }

        // Reset game
        function resetGame() {
            score = 0;
            level = 1;
            timeLeft = 60;
            goal = 200;
            gameOver = false;
            initGrid();
            requestAnimationFrame(gameLoop);
        }

        // Click handling
        canvas.addEventListener('click', (e) => {
            if (gameOver) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);

            if (!selected) {
                selected = { x, y };
            } else if (isAdjacent(selected, { x, y })) {
                if (swapCandies(selected, { x, y })) {
                    let hasMatches = true;
                    while (hasMatches) {
                        hasMatches = clearMatches();
                        if (hasMatches) {
                            dropCandies();
                            drawGrid(); // Update visuals during cascades
                        }
                    }
                    if (score >= goal) nextLevel();
                    if (!hasMoves()) {
                        gameOver = true;
                        alert(`Game Over! No moves left. Score: ${score}\nReload to retry.`);
                    }
                }
                selected = null;
            } else {
                selected = { x, y };
            }
        });

        // Game loop
        function gameLoop(timestamp) {
            if (gameOver) return;
            const delta = (timestamp - lastFrame) / 1000;
            lastFrame = timestamp;

            timeLeft -= delta;
            if (timeLeft <= 0) {
                gameOver = true;
                alert(`Time's Up! Score: ${score}\nReload to retry.`);
            }

            // Update animations
            const hasAnimations = updateAnimations(delta);
            drawGrid();

            scoreUI.textContent = `Score: ${score}`;
            levelUI.textContent = `Level: ${level}`;
            timeUI.textContent = `Time: ${Math.max(0, Math.floor(timeLeft))}`;
            goalUI.textContent = `Goal: ${goal}`;

            requestAnimationFrame(gameLoop);
        }

        // Start game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
