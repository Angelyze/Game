<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wasteland Candy Crush</title>
    <style>
        body { margin: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background: #1a1a1a; font-family: Arial, sans-serif; }
        #gameContainer { position: relative; }
        canvas { border: 4px solid #4a4a4a; border-radius: 8px; background: linear-gradient(#2f2f2f, #3c3c3c); box-shadow: 0 0 15px rgba(0, 255, 0, 0.2); }
        #ui { 
            display: flex; justify-content: space-between; width: 360px; 
            background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px; 
            color: #0f0; font-size: 18px; margin-bottom: 10px; text-shadow: 0 0 5px #0f0; 
        }
        #ui span { background: #222; padding: 5px 10px; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="ui">
        <span id="score">Score: 0</span>
        <span id="level">Level: 1</span>
        <span id="time">Time: 60</span>
        <span id="goal">Goal: 100</span>
    </div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="360" height="360"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreUI = document.getElementById('score');
        const levelUI = document.getElementById('level');
        const timeUI = document.getElementById('time');
        const goalUI = document.getElementById('goal');

        // Game settings
        const GRID_SIZE = 6;
        const TILE_SIZE = 60;
        const CANDY_TYPES = [
            '#ff5555', // Glowing Gum
            '#55ff55', // Toxic Taffy
            '#5555ff', // Rad Rocks
            '#ffff55', // Mutant Mints
            '#ff55ff', // Irradiated Drops
            '#00ffff'  // Cyan (added for higher levels)
        ];

        // Game state
        let grid = [];
        let score = 0;
        let level = 1;
        let timeLeft = 60;
        let goal = 100;
        let selected = null;
        let gameOver = false;
        let lastFrame = performance.now();

        // Initialize grid
        function initGrid() {
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0).map(() => Math.floor(Math.random() * (3 + Math.min(level, 3)))));
            while (findMatches().length > 0) clearMatches(); // Ensure no initial matches
        }
        initGrid();

        // Draw candy
        function drawCandy(x, y, type) {
            ctx.fillStyle = CANDY_TYPES[type];
            ctx.beginPath();
            ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2 - 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke(); // Add outline for pop
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(x * TILE_SIZE + TILE_SIZE / 2 - 10, y * TILE_SIZE + TILE_SIZE / 2 - 10, 5, 0, Math.PI * 2);
            ctx.fill(); // Shine effect
        }

        // Draw grid
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE - 2, TILE_SIZE - 2); // Grid cells
                    if (grid[y][x] !== -1) drawCandy(x, y, grid[y][x]);
                }
            }
            if (selected) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 4;
                ctx.strokeRect(selected.x * TILE_SIZE, selected.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }

        // Find matches
        function findMatches() {
            let matches = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE - 2; x++) {
                    if (grid[y][x] >= 0 && grid[y][x] === grid[y][x + 1] && grid[y][x] === grid[y][x + 2]) {
                        matches.push({ x: x, y: y }, { x: x + 1, y: y }, { x: x + 2, y: y });
                    }
                }
            }
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE - 2; y++) {
                    if (grid[y][x] >= 0 && grid[y][x] === grid[y + 1][x] && grid[y][x] === grid[y + 2][x]) {
                        matches.push({ x: x, y: y }, { x: x, y: y + 1 }, { x: x, y: y + 2 });
                    }
                }
            }
            return matches;
        }

        // Clear matches
        function clearMatches() {
            let matches = findMatches();
            if (matches.length === 0) return false;
            matches.forEach(match => {
                if (grid[match.y][match.x] !== -1) {
                    grid[match.y][match.x] = -1;
                    score += 10 * level; // Scale score with level
                }
            });
            dropCandies();
            return true;
        }

        // Drop candies
        function dropCandies() {
            for (let x = 0; x < GRID_SIZE; x++) {
                let column = [];
                for (let y = GRID_SIZE - 1; y >= 0; y--) {
                    if (grid[y][x] !== -1) column.push(grid[y][x]);
                }
                while (column.length < GRID_SIZE) column.unshift(Math.floor(Math.random() * (3 + Math.min(level, 3))));
                for (let y = 0; y < GRID_SIZE; y++) grid[y][x] = column[y];
            }
        }

        // Check adjacency
        function isAdjacent(pos1, pos2) {
            return (Math.abs(pos1.x - pos2.x) === 1 && pos1.y === pos2.y) || 
                   (Math.abs(pos1.y - pos2.y) === 1 && pos1.x === pos2.x);
        }

        // Swap candies
        function swapCandies(pos1, pos2) {
            const temp = grid[pos1.y][pos1.x];
            grid[pos1.y][pos1.x] = grid[pos2.y][pos2.x];
            grid[pos2.y][pos2.x] = temp;

            const hasMatch = findMatches().length > 0;
            if (!hasMatch) {
                grid[pos2.y][pos2.x] = grid[pos1.y][pos1.x];
                grid[pos1.y][pos1.x] = temp; // Undo swap
            } else {
                clearMatches();
            }
            return hasMatch;
        }

        // Check for moves
        function hasMoves() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (x < GRID_SIZE - 1) {
                        [grid[y][x], grid[y][x + 1]] = [grid[y][x + 1], grid[y][x]];
                        if (findMatches().length > 0) {
                            [grid[y][x], grid[y][x + 1]] = [grid[y][x + 1], grid[y][x]];
                            return true;
                        }
                        [grid[y][x], grid[y][x + 1]] = [grid[y][x + 1], grid[y][x]];
                    }
                    if (y < GRID_SIZE - 1) {
                        [grid[y][x], grid[y + 1][x]] = [grid[y + 1][x], grid[y][x]];
                        if (findMatches().length > 0) {
                            [grid[y][x], grid[y + 1][x]] = [grid[y + 1][x], grid[y][x]];
                            return true;
                        }
                        [grid[y][x], grid[y + 1][x]] = [grid[y + 1][x], grid[y][x]];
                    }
                }
            }
            return false;
        }

        // Level progression
        function nextLevel() {
            if (level >= 10) {
                gameOver = true;
                alert(`Vault Cleared! Final Score: ${score}`);
                return;
            }
            level++;
            timeLeft = 60;
            goal += 50 * level; // Increase goal each level
            initGrid();
        }

        // Click handling
        canvas.addEventListener('click', (e) => {
            if (gameOver) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);

            if (!selected) {
                selected = { x, y };
            } else if (isAdjacent(selected, { x, y })) {
                if (swapCandies(selected, { x, y })) {
                    if (score >= goal) nextLevel();
                    if (!hasMoves()) {
                        gameOver = true;
                        alert(`Game Over! No moves left. Score: ${score}`);
                    }
                }
                selected = null;
            } else {
                selected = { x, y };
            }
        });

        // Game loop
        function gameLoop(timestamp) {
            if (gameOver) return;
            const delta = (timestamp - lastFrame) / 1000;
            lastFrame = timestamp;

            timeLeft -= delta;
            if (timeLeft <= 0) {
                gameOver = true;
                alert(`Time's Up! Score: ${score}`);
            }

            drawGrid();
            scoreUI.textContent = `Score: ${score}`;
            levelUI.textContent = `Level: ${level}`;
            timeUI.textContent = `Time: ${Math.max(0, Math.floor(timeLeft))}`;
            goalUI.textContent = `Goal: ${goal}`;

            requestAnimationFrame(gameLoop);
        }

        // Start game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
